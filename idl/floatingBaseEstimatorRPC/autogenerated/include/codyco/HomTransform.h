/*
 * SPDX-FileCopyrightText: 2006-2021 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: BSD-3-Clause
 */

// Autogenerated by Thrift Compiler (0.14.1-yarped)
//
// This is an automatically generated file.
// It could get re-generated if the ALLOW_IDL_GENERATION flag is on.

#ifndef YARP_THRIFT_GENERATOR_STRUCT_HOMTRANSFORM_H
#define YARP_THRIFT_GENERATOR_STRUCT_HOMTRANSFORM_H

#include <yarp/os/Wire.h>
#include <yarp/os/idl/WireTypes.h>

namespace codyco {

/**
 * Structure representing an homogeneous transform, i.e.
 * a 4x4 matrix with structure:
 * B_H_C = ( xx xy xz x )
 *         ( yx yy yz y )
 *         ( zx zy zz z )
 *         (  0  0  0 1 )
 * A matrix like that respresents the location of a frame C w.r.t. to a frame B.
 * For more information on the semantics of such transformation, please
 * refer to http://repository.tue.nl/849895 .
 */
class HomTransform :
        public yarp::os::idl::WirePortable
{
public:
    // Fields
    double x;
    double y;
    double z;
    double xx;
    double xy;
    double xz;
    double yx;
    double yy;
    double yz;
    double zx;
    double zy;
    double zz;

    // Default constructor
    HomTransform();

    // Constructor with field values
    HomTransform(const double x,
                 const double y,
                 const double z,
                 const double xx,
                 const double xy,
                 const double xz,
                 const double yx,
                 const double yy,
                 const double yz,
                 const double zx,
                 const double zy,
                 const double zz);

    // Read structure on a Wire
    bool read(yarp::os::idl::WireReader& reader) override;

    // Read structure on a Connection
    bool read(yarp::os::ConnectionReader& connection) override;

    // Write structure on a Wire
    bool write(const yarp::os::idl::WireWriter& writer) const override;

    // Write structure on a Connection
    bool write(yarp::os::ConnectionWriter& connection) const override;

    // Convert to a printable string
    std::string toString() const;

    // If you want to serialize this class without nesting, use this helper
    typedef yarp::os::idl::Unwrapped<HomTransform> unwrapped;

    class Editor :
            public yarp::os::Wire,
            public yarp::os::PortWriter
    {
    public:
        // Editor: default constructor
        Editor();

        // Editor: constructor with base class
        Editor(HomTransform& obj);

        // Editor: destructor
        ~Editor() override;

        // Editor: Deleted constructors and operator=
        Editor(const Editor& rhs) = delete;
        Editor(Editor&& rhs) = delete;
        Editor& operator=(const Editor& rhs) = delete;
        Editor& operator=(Editor&& rhs) = delete;

        // Editor: edit
        bool edit(HomTransform& obj, bool dirty = true);

        // Editor: validity check
        bool isValid() const;

        // Editor: state
        HomTransform& state();

        // Editor: start editing
        void start_editing();

#ifndef YARP_NO_DEPRECATED // Since YARP 3.2
        YARP_DEPRECATED_MSG("Use start_editing() instead")
        void begin()
        {
            start_editing();
        }
#endif // YARP_NO_DEPRECATED

        // Editor: stop editing
        void stop_editing();

#ifndef YARP_NO_DEPRECATED // Since YARP 3.2
        YARP_DEPRECATED_MSG("Use stop_editing() instead")
        void end()
        {
            stop_editing();
        }
#endif // YARP_NO_DEPRECATED

        // Editor: x field
        void set_x(const double x);
        double get_x() const;
        virtual bool will_set_x();
        virtual bool did_set_x();

        // Editor: y field
        void set_y(const double y);
        double get_y() const;
        virtual bool will_set_y();
        virtual bool did_set_y();

        // Editor: z field
        void set_z(const double z);
        double get_z() const;
        virtual bool will_set_z();
        virtual bool did_set_z();

        // Editor: xx field
        void set_xx(const double xx);
        double get_xx() const;
        virtual bool will_set_xx();
        virtual bool did_set_xx();

        // Editor: xy field
        void set_xy(const double xy);
        double get_xy() const;
        virtual bool will_set_xy();
        virtual bool did_set_xy();

        // Editor: xz field
        void set_xz(const double xz);
        double get_xz() const;
        virtual bool will_set_xz();
        virtual bool did_set_xz();

        // Editor: yx field
        void set_yx(const double yx);
        double get_yx() const;
        virtual bool will_set_yx();
        virtual bool did_set_yx();

        // Editor: yy field
        void set_yy(const double yy);
        double get_yy() const;
        virtual bool will_set_yy();
        virtual bool did_set_yy();

        // Editor: yz field
        void set_yz(const double yz);
        double get_yz() const;
        virtual bool will_set_yz();
        virtual bool did_set_yz();

        // Editor: zx field
        void set_zx(const double zx);
        double get_zx() const;
        virtual bool will_set_zx();
        virtual bool did_set_zx();

        // Editor: zy field
        void set_zy(const double zy);
        double get_zy() const;
        virtual bool will_set_zy();
        virtual bool did_set_zy();

        // Editor: zz field
        void set_zz(const double zz);
        double get_zz() const;
        virtual bool will_set_zz();
        virtual bool did_set_zz();

        // Editor: clean
        void clean();

        // Editor: read
        bool read(yarp::os::ConnectionReader& connection) override;

        // Editor: write
        bool write(yarp::os::ConnectionWriter& connection) const override;

    private:
        // Editor: state
        HomTransform* obj;
        bool obj_owned;
        int group;

        // Editor: dirty variables
        bool is_dirty;
        bool is_dirty_x;
        bool is_dirty_y;
        bool is_dirty_z;
        bool is_dirty_xx;
        bool is_dirty_xy;
        bool is_dirty_xz;
        bool is_dirty_yx;
        bool is_dirty_yy;
        bool is_dirty_yz;
        bool is_dirty_zx;
        bool is_dirty_zy;
        bool is_dirty_zz;
        int dirty_count;

        // Editor: send if possible
        void communicate();

        // Editor: mark dirty overall
        void mark_dirty();

        // Editor: mark dirty single fields
        void mark_dirty_x();
        void mark_dirty_y();
        void mark_dirty_z();
        void mark_dirty_xx();
        void mark_dirty_xy();
        void mark_dirty_xz();
        void mark_dirty_yx();
        void mark_dirty_yy();
        void mark_dirty_yz();
        void mark_dirty_zx();
        void mark_dirty_zy();
        void mark_dirty_zz();

        // Editor: dirty_flags
        void dirty_flags(bool flag);
    };

private:
    // read/write x field
    bool read_x(yarp::os::idl::WireReader& reader);
    bool write_x(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_x(yarp::os::idl::WireReader& reader);
    bool nested_write_x(const yarp::os::idl::WireWriter& writer) const;

    // read/write y field
    bool read_y(yarp::os::idl::WireReader& reader);
    bool write_y(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_y(yarp::os::idl::WireReader& reader);
    bool nested_write_y(const yarp::os::idl::WireWriter& writer) const;

    // read/write z field
    bool read_z(yarp::os::idl::WireReader& reader);
    bool write_z(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_z(yarp::os::idl::WireReader& reader);
    bool nested_write_z(const yarp::os::idl::WireWriter& writer) const;

    // read/write xx field
    bool read_xx(yarp::os::idl::WireReader& reader);
    bool write_xx(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_xx(yarp::os::idl::WireReader& reader);
    bool nested_write_xx(const yarp::os::idl::WireWriter& writer) const;

    // read/write xy field
    bool read_xy(yarp::os::idl::WireReader& reader);
    bool write_xy(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_xy(yarp::os::idl::WireReader& reader);
    bool nested_write_xy(const yarp::os::idl::WireWriter& writer) const;

    // read/write xz field
    bool read_xz(yarp::os::idl::WireReader& reader);
    bool write_xz(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_xz(yarp::os::idl::WireReader& reader);
    bool nested_write_xz(const yarp::os::idl::WireWriter& writer) const;

    // read/write yx field
    bool read_yx(yarp::os::idl::WireReader& reader);
    bool write_yx(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_yx(yarp::os::idl::WireReader& reader);
    bool nested_write_yx(const yarp::os::idl::WireWriter& writer) const;

    // read/write yy field
    bool read_yy(yarp::os::idl::WireReader& reader);
    bool write_yy(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_yy(yarp::os::idl::WireReader& reader);
    bool nested_write_yy(const yarp::os::idl::WireWriter& writer) const;

    // read/write yz field
    bool read_yz(yarp::os::idl::WireReader& reader);
    bool write_yz(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_yz(yarp::os::idl::WireReader& reader);
    bool nested_write_yz(const yarp::os::idl::WireWriter& writer) const;

    // read/write zx field
    bool read_zx(yarp::os::idl::WireReader& reader);
    bool write_zx(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_zx(yarp::os::idl::WireReader& reader);
    bool nested_write_zx(const yarp::os::idl::WireWriter& writer) const;

    // read/write zy field
    bool read_zy(yarp::os::idl::WireReader& reader);
    bool write_zy(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_zy(yarp::os::idl::WireReader& reader);
    bool nested_write_zy(const yarp::os::idl::WireWriter& writer) const;

    // read/write zz field
    bool read_zz(yarp::os::idl::WireReader& reader);
    bool write_zz(const yarp::os::idl::WireWriter& writer) const;
    bool nested_read_zz(yarp::os::idl::WireReader& reader);
    bool nested_write_zz(const yarp::os::idl::WireWriter& writer) const;
};

} // namespace codyco

#endif // YARP_THRIFT_GENERATOR_STRUCT_HOMTRANSFORM_H
